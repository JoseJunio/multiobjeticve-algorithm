#include <gsl/gsl_rng.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <time.h>
#include <limits.h>
#include <stdbool.h>

#define MAXPOP 500

//variaveis globais
double etc[512][16];
int tasks;
int machines;
gsl_rng *r;
char path[1000]; //= "/Users/josejunio/Documents/Mestrado/Distribute_MultiObjective_Scheduling_C/u_c_hihi.0";
int popSize;
int maxGen;

struct Solution{
  int Mapping[512];   // chromosome
  double Load[16];    // load of the machines
  double fit;         // fitness of the solution
  double makespan;
  double varload;
  double ct[512][16];
};

void initialize_params(){
    /*tasks = 512;
    machines = 16;
    popSize = atoi("300");
    maxGen = atoi("2000");
*/

    FILE *fr;

    fr = fopen("/Users/josejunio/Desktop/Algoritmos/multiobjeticve-algorithm/parameters.txt", "r");

    char tmpstr1[16];
    char tmpstr2[400];

    char tempbuff[500];

    while(!feof(fr)){
     if (fgets(tempbuff,500,fr)) {

        sscanf(tempbuff, "%s : %s", tmpstr1, tmpstr2);

        if (strcmp(tmpstr1,"fileName")==0) {
             strcpy(path, tmpstr2) ;
        } else if (strcmp(tmpstr1,"popSize")==0) {
             popSize = atoi(tmpstr2);
        } else if (strcmp(tmpstr1,"maxGen")==0) {
             maxGen = atoi(tmpstr2);
        } else if (strcmp(tmpstr1,"tasks")==0) {
             tasks = atoi(tmpstr2);
        } else if (strcmp(tmpstr1,"machines")==0) {
             machines = atoi(tmpstr2);
        }
     }
   }

    fclose(fr);
}

double makespan(double *load){
  int j;

  double max = -1;

  for (j = 0; j < machines; j++) {
    //printf("machine: %d\n", j);
    //printf("value: %lf\n", load[j]);
    if (load[j] > max) {
      max = load[j];
    }
  }

  return -max;
}

double diffload(double *load){
  int j;
  double min, max;

  min = (double) INT_MAX;
  max = -1;

  for (j = 0; j < machines; j++) {
    if (load[j] > max){
       max = load[j];
    }

    if (load[j] < min){
       min = load[j];
    }
  }

  return -(max - min);
}

void compute_load(struct Solution *l){
  int i, j;
  double load;

  for (j = 0; j < machines; j++){
    load = 0.0;
    for (i = 0; i < tasks; i++){
      if (l->Mapping[i] == j){
        load += etc[i][j];
      }
    }
    l->Load[j] = load;
  }
}

struct Solution *min_min(){

    struct Solution *l;

    l = (struct Solution *)malloc(sizeof(struct Solution));

    for(int i=0; i<tasks; i++){
        for(int j=0; j<machines; j++){
            l->ct[i][j] = etc[i][j];
            //fprintf(stdout, "%d\t %d\t %lf\n", i, j, l->ct[i][j]);
        }
    }

    int numTasks = tasks;

    bool isRemoved[tasks];

    //inicializa com false
    for(int i=0; i<tasks; i++){
        isRemoved[i] = false;
    }

    do{

        double minValue = (double) INT_MAX;
        int machine=-1;
        int task=-1;

        for(int i=0; i<tasks; i++){

            if(isRemoved[i]){
             continue;
            }

            for(int j=0; j<machines; j++){
                if(l->ct[i][j] < minValue){
                    minValue = l->ct[i][j];
                    machine = j;
                    task = i;
                }
            }
        }

        l->Load[machine] = minValue;
        l->Mapping[task] = machine;
        isRemoved[task] = true;

        for(int i=0; i<tasks; i++){
            /*if(isRemoved[i]){
             continue;
            }*/

            l->ct[i][machine] = etc[i][machine] + l->Load[machine];

        }


       numTasks--;
    } while(numTasks > 0);


    l->makespan = makespan(l->Load);
    l->varload = diffload(l->Load);
    l->fit = l->makespan;

    return l;
};

struct Solution *RandomMap(){
  struct Solution *l;
  int i;

  l = (struct Solution *)malloc(sizeof(struct Solution));

  for (i = 0; i < tasks; i++){
    l->Mapping[i] = gsl_rng_uniform_int(r, machines);
  }

  compute_load(l);
  l->makespan = makespan(l->Load);
  l->varload = diffload(l->Load);
  l->fit = l->makespan;

  return l;
}

struct Solution *copySol(struct Solution *l1){
  int i;
  struct Solution *l;

  l = (struct Solution *)malloc(sizeof(struct Solution));

  for (i = 0; i < tasks; i++){
    l->Mapping[i] = l1->Mapping[i];
  }

  l->fit = l1->fit;
  l->makespan = l1->makespan;
  l->varload = diffload(l->Load);

  return l;
}

//Mutations
struct Solution *Mutation(struct Solution *l1){
  int a, b, z;
  int tmp;
  struct Solution *l;
  l = copySol(l1);

  b = gsl_rng_uniform_int(r, tasks);
  do {
    z = gsl_rng_uniform_int(r, tasks);;
  } while (l->Mapping[z] == l->Mapping[b]);

  tmp = l->Mapping[b];
  l->Mapping[b] = l->Mapping[z];
  l->Mapping[z] = tmp;

  compute_load(l);
  l->makespan = makespan(l->Load);
  l->varload = diffload(l->Load);

  l->fit = l->makespan;

  return l;
}

struct Solution *Mutation1(struct Solution *l1){
  int b, z, tmp;

  struct Solution *l;
  l = copySol(l1);

  b = gsl_rng_uniform_int(r, tasks);
  z = gsl_rng_uniform_int(r, machines);;

  tmp = l->Mapping[b];
  l->Mapping[b] = z;

  compute_load(l);
  l->makespan = makespan(l->Load);
  l->varload = diffload(l->Load);

  l->fit = l->makespan;

  return l;
}

struct Solution *Pairing(struct Solution *l1, struct Solution *l2, double c){
  int a, b, z;
  double average;
  struct Solution *l;
  l = (struct Solution *)malloc(sizeof(struct Solution));

  average = (l1->fit + l2->fit) / 2.0;

  b = gsl_rng_uniform_int(r, tasks-1);

  for (a = 0; a < b; a++){
    l->Mapping[a] = l1->Mapping[a];
  }

  for (a = b + 1; a < tasks; a++){
    l->Mapping[a] = l2->Mapping[a];
  }

  z = gsl_rng_uniform_int(r, machines);

  l->Mapping[b] = z;

  compute_load(l);
  l->makespan = makespan(l->Load);

  l->varload = diffload(l->Load);
  l->fit = l->makespan;

  if (l->fit > average || gsl_rng_uniform_pos(r) < exp((l->fit - average) / c)){
    return l;
  }

  free(l);
  return NULL;
}

int main(int argc, char *argv[]){

    initialize_params();

    static struct Solution *PopA[MAXPOP];
    static struct Solution *PopB[MAXPOP];
    static struct Solutions *temp;

    if((r = gsl_rng_alloc(gsl_rng_mt19937)) == NULL) {
        fprintf(stderr, "ERROR: Could not create random number generator\n");
        return EXIT_FAILURE;
    }

    gsl_rng_set(r, time(NULL));

    FILE *fp;

    fp = fopen(path, "r");

    if (fp == NULL){
        perror(path);
    }

    int a, b;

    for (a = 0; a < tasks; a++) {
        for (b = 0; b < machines; b++){
          fscanf(fp, "%lf", &etc[a][b]);
          //fprintf(stdout, "%d\t %d\t %lf\n", a, b, etc[a][b]);
        }
    }

    fclose(fp);

    PopA[0] = min_min();

    printf("%lf", PopA[0]->fit);

    for (a = 1; a < popSize; a++) {
        PopA[a] = RandomMap();
        printf("Initialize %d \n", a);
    }

    printf("Start Evolution \n");

    int best = 0;
    double tmp, tmp1, popFit = 0.0;
    double c = 2.0;
    long e = 0;
    b = 0;

    while (e < maxGen) {
        e++;

        if (e % 4 == 0){
            c = 0.99 * c;
        }

        printf("Best makespan %lf (%lf) in Generation %d \n", PopA[0]->fit, PopA[0]->varload, e);

        for (b = 0; b < 10; b++){
            // Mutations
            //   Indice 0 = Mutation
            //    Na Mutation pegamos a popB e a partir de sua mutação geramos a popA

            //   Indice 1 = Mutation 1
            //    Na Mutation1 pegamos a popA e a partir de sua mutação geramos a popB

            for(int i=0; i<2; i++){

                best = 0;
                tmp = (i == 0) ? PopA[0]->fit : PopB[0]->fit;
                popFit = tmp;

                for (b = 1; b < popSize; b++){
                    tmp1 = (i == 0) ? PopA[b]->fit : PopB[b]->fit;
                    popFit += tmp1;

                    if (tmp1 >= tmp){
                      tmp = tmp1;
                      best = b;
                    }
                }

                if(i == 0){
                    PopB[0] = copySol(PopA[best]);
                } else if(i == 1){
                    PopA[0] = copySol(PopB[best]);
                }

                a = 1;
                best = 0;
                while (a < popSize) {
                    if(i == 0){
                        PopB[a] = Mutation(PopA[a]);

                        if (PopB[a] == NULL) {
                          continue;
                        }

                    } else if(i == 1){
                        PopA[a] = Mutation1(PopB[a]);

                        if (PopA[a] == NULL){
                          continue;
                        }
                    }

                    a++;
                }

                for (a = 0; a < popSize; a++){
                    if(i == 0){
                        free(PopA[a]);
                    } else if(i == 1){
                        free(PopB[a]);
                    }
                }
            }
        }

        for(int i=0; i<2; i++){
            int x, y;
            best = 0;

            tmp = (i == 0) ? PopA[0]->fit : PopB[0]->fit;
            popFit = tmp;

            for (b = 1; b < popSize; b++) {
              tmp1 = (i == 0) ? PopA[b]->fit : PopB[b]->fit;
              popFit += tmp1;
              if (tmp1 >= tmp){
                tmp = tmp1;
                best = b;
              }
            }

            if(i == 0){
                PopB[0] = copySol(PopA[best]);
            } else if(i == 1){
                PopA[0] = copySol(PopB[best]);
            }

            a=1;
            while (a < popSize){

              double fit = 0.0;

              do{
                x = gsl_rng_uniform_int(r, popSize-1);

                fit = (i == 0) ? PopA[x]->fit : PopB[x]->fit;

              } while (popFit > 0 && gsl_rng_uniform_pos(r) > fit / popFit);

              do{
                y = gsl_rng_uniform_int(r, popSize-1);

                fit = (i == 0) ? PopA[y]->fit : PopB[y]->fit;

              } while (popFit > 0 && gsl_rng_uniform_pos(r) > fit / popFit);

              if(i == 0){
                PopB[a] = Pairing(PopA[x], PopA[y], c);

                if (PopB[a] == NULL) {
                    continue;
                }

              } else if(i == 1){
                 PopA[a] = Pairing(PopB[x], PopB[y], c);

                 if (PopA[a] == NULL){
                    continue;
                 }
              }
              a++;
            }

            for (a = 0; a < popSize; a++){
                if(i == 0){
                    free(PopA[a]);
                } else if(i == 1){
                    free(PopB[a]);
                }
            }

        }

    }

    printf(" Generation %d", e);
    printf("\n%lf\t%lf\t%lf\n", PopA[0]->fit, PopA[0]->makespan, PopA[0]->varload);

    for (a = 0; a < popSize; a++){
        for (b = 0; b < tasks; b++) {
          printf("%d \n", PopA[a]->Mapping[b]);
        }
        fprintf(stdout, "%lf ", PopA[a]->fit);
    }

    return EXIT_SUCCESS;
}

